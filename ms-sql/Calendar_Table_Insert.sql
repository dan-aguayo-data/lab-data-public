-- Generate a date dimension table from 2020-01-01 to 2030-12-31


WITH DateSequence AS (
    SELECT CAST('2020-01-01' AS DATE) AS [Date]
    UNION ALL
    SELECT DATEADD(DAY, 1, [Date])
    FROM DateSequence
    WHERE [Date] < '2030-12-31'
)
INSERT INTO SalesLT.Calendar (
    CALENDAR_ID, [DATE], [DAY], DAYSUFFIX, WEEKDAY, WEEKDAYNAME, ISWEEKEND, HOLIDAYTEXT, DOWINMONTH,
    DAYOFYEAR, WEEKOFMONTH, WEEKOFYEAR, ISOWEEKOFYEAR, [MONTH], MONTHNAME, [QUARTER], QUARTERNAME, [YEAR],
    MMYYYY, MONTHYEAR, FIRSTDAYOFMONTH, LASTDAYOFMONTH, FIRSTDAYOFQUARTER, LASTDAYOFQUARTER,
    FIRSTDAYOFYEAR, LASTDAYOFYEAR, FIRSTDAYOFNEXTMONTH, FIRSTDAYOFNEXTYEAR, HasData, InFuture,
    QUARTERYEAR, YYYYMM, QUARTER_CODE, FY_QUARTER_CODE, FY_QUARTER, FY_MONTH, FY_MONTHNAME,
    FY_YEAR, FY_WEEKOFYEAR, FY_MMYYYY, FY_YYYYMM, FY_CODE, ISHOLIDAY_AUS, DAY_NUMBER, DAYS_PER_MONTH,
    SALES_DATE_ID, FIRSTDAY_FLAG, LASTDAY_FLAG, DSR_DAYS_PER_MONTH_REPORTING
)
SELECT
    -- Main IDs
    CONVERT(INT, FORMAT([Date], 'yyyyMMdd')) AS CALENDAR_ID,
    DATEDIFF(DAY, '1899-12-30', [Date]) AS [DATE], -- Excel serial date
    
    -- Basic Date Parts
    DATEPART(DAY, [Date]) AS [DAY],
    CASE 
        WHEN DATEPART(DAY, [Date]) IN (11,12,13) THEN 'th'
        WHEN RIGHT(CAST(DATEPART(DAY, [Date]) AS VARCHAR(2)), 1) = '1' THEN 'st'
        WHEN RIGHT(CAST(DATEPART(DAY, [Date]) AS VARCHAR(2)), 1) = '2' THEN 'nd'
        WHEN RIGHT(CAST(DATEPART(DAY, [Date]) AS VARCHAR(2)), 1) = '3' THEN 'rd'
        ELSE 'th'
    END AS DAYSUFFIX,
    DATEPART(WEEKDAY, [Date]) AS WEEKDAY,
    DATENAME(WEEKDAY, [Date]) AS WEEKDAYNAME,
    CASE WHEN DATEPART(WEEKDAY, [Date]) IN (1,7) THEN 'TRUE' ELSE 'FALSE' END AS ISWEEKEND,

    -- Placeholders (replace NULL with real logic or joins for holidays)
    NULL AS HOLIDAYTEXT, 

    -- Advanced Parts
    DENSE_RANK() OVER (PARTITION BY YEAR([Date]), MONTH([Date]) ORDER BY [Date]) AS DOWINMONTH,
    DATEPART(DAYOFYEAR, [Date]) AS DAYOFYEAR,
    (DATEPART(DAY, [Date]) - 1) / 7 + 1 AS WEEKOFMONTH,
    DATEPART(WEEK, [Date]) AS WEEKOFYEAR,
    DATEPART(ISO_WEEK, [Date]) AS ISOWEEKOFYEAR,
    MONTH([Date]) AS [MONTH],
    DATENAME(MONTH, [Date]) AS MONTHNAME,
    DATEPART(QUARTER, [Date]) AS [QUARTER],
    CASE DATEPART(QUARTER, [Date])
        WHEN 1 THEN 'First'
        WHEN 2 THEN 'Second'
        WHEN 3 THEN 'Third'
        WHEN 4 THEN 'Fourth'
    END AS QUARTERNAME,
    YEAR([Date]) AS [YEAR],
    -- MMYYYY as in your sample (month then year, no leading zero)
    (MONTH([Date]) * 10000) + YEAR([Date]) AS MMYYYY,
    -- MonthYear: using Excel serial of first of month
    DATEDIFF(DAY, '1899-12-30', DATEFROMPARTS(YEAR([Date]), MONTH([Date]), 1)) AS MONTHYEAR,
    -- First/last day of month as Excel serial
    DATEDIFF(DAY, '1899-12-30', DATEFROMPARTS(YEAR([Date]), MONTH([Date]), 1)) AS FIRSTDAYOFMONTH,
    DATEDIFF(DAY, '1899-12-30', EOMONTH([Date])) AS LASTDAYOFMONTH,
    -- First/last day of quarter
    DATEDIFF(DAY, '1899-12-30', DATEADD(QUARTER, DATEDIFF(QUARTER, 0, [Date]), 0)) AS FIRSTDAYOFQUARTER,
    DATEDIFF(DAY, '1899-12-30', DATEADD(DAY, -1, DATEADD(QUARTER, 1, DATEADD(QUARTER, DATEDIFF(QUARTER, 0, [Date]), 0)))) AS LASTDAYOFQUARTER,
    -- First/last day of year
    DATEDIFF(DAY, '1899-12-30', DATEFROMPARTS(YEAR([Date]), 1, 1)) AS FIRSTDAYOFYEAR,
    DATEDIFF(DAY, '1899-12-30', DATEFROMPARTS(YEAR([Date]), 12, 31)) AS LASTDAYOFYEAR,
    -- Next month/year
    DATEDIFF(DAY, '1899-12-30', DATEADD(MONTH, 1, DATEFROMPARTS(YEAR([Date]), MONTH([Date]), 1))) AS FIRSTDAYOFNEXTMONTH,
    DATEDIFF(DAY, '1899-12-30', DATEFROMPARTS(YEAR([Date]) + 1, 1, 1)) AS FIRSTDAYOFNEXTYEAR,

    -- Business columns (fill logic as needed)
    'Yes' AS HasData, -- Placeholder
    CASE WHEN [Date] > CAST(GETDATE() AS DATE) THEN 'Yes' ELSE 'No' END AS InFuture,

    -- Combined columns
    CONCAT('Q', DATEPART(QUARTER, [Date]), ' ', YEAR([Date])) AS QUARTERYEAR,
    YEAR([Date]) * 100 + MONTH([Date]) AS YYYYMM,
    CONCAT('Q', DATEPART(QUARTER, [Date])) AS QUARTER_CODE,

    -- Fiscal year logic (assume July-June for Australia)
    CONCAT('Q', ((DATEPART(QUARTER, DATEADD(MONTH, -6, [Date]))) % 4) + 1) AS FY_QUARTER_CODE,
    ((DATEPART(QUARTER, DATEADD(MONTH, -6, [Date]))) % 4) + 1 AS FY_QUARTER,
    MONTH(DATEADD(MONTH, -6, [Date])) AS FY_MONTH,
    DATENAME(MONTH, DATEADD(MONTH, -6, [Date])) AS FY_MONTHNAME,
    YEAR(DATEADD(MONTH, -6, [Date])) AS FY_YEAR,
    DATEPART(WEEK, DATEADD(MONTH, -6, [Date])) AS FY_WEEKOFYEAR,
    (MONTH(DATEADD(MONTH, -6, [Date])) * 10000) + YEAR(DATEADD(MONTH, -6, [Date])) AS FY_MMYYYY,
    YEAR(DATEADD(MONTH, -6, [Date])) * 100 + MONTH(DATEADD(MONTH, -6, [Date])) AS FY_YYYYMM,
    CONCAT('FY', RIGHT(CAST(YEAR(DATEADD(MONTH, -6, [Date]))-1 AS VARCHAR(4)),2), '/', RIGHT(CAST(YEAR(DATEADD(MONTH, -6, [Date])) AS VARCHAR(4)),2)) AS FY_CODE,

    -- Placeholder for public holiday logic
    'FALSE' AS ISHOLIDAY_AUS,

    DATEPART(DAY, [Date]) AS DAY_NUMBER,
    DAY(EOMONTH([Date])) AS DAYS_PER_MONTH,

    -- Sales Date ID (replicate as CALENDAR_ID, or use your own logic)
    CONVERT(INT, FORMAT([Date], 'yyyyMMdd')) AS SALES_DATE_ID,

    CASE WHEN [Date] = DATEFROMPARTS(YEAR([Date]), MONTH([Date]), 1) THEN 'TRUE' ELSE 'FALSE' END AS FIRSTDAY_FLAG,
    CASE WHEN [Date] = EOMONTH([Date]) THEN 'Yes' ELSE 'No' END AS LASTDAY_FLAG,

    21 AS DSR_DAYS_PER_MONTH_REPORTING -- Placeholder

FROM DateSequence
OPTION (MAXRECURSION 32767);
